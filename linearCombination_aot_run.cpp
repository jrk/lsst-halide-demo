/*
 * This file serves of an example of how to use an "ahead of time"
 * compiled Halide pipeline in an application.  The compilation
 * process generated a .o (linked against in this application's build
 * process) as well as header file (lincombo_aot.h) that is included
 * below.
 *
 */

// This is the header file generated by ahead of time compilating
// process.  We just include it here like any other C header:
#include "lincombo_aot.h"
// Note, we DON'T have to include or link against Halide at all in
// this program. The generated code is entirely standalone, self-contained
// in lincombo_aot.o and lincombo_aot.h, which are emitted when we run
// linearCombination_aot_compile.

//#define USE_LSST_FITS_IO to build with FITS IO from the LSST stack
// This will likely require setting additional include and link flags
// to build this final program.
#ifdef USE_LSST_FITS_IO
#include "lsst/afw/image.h"
namespace afwImage = lsst::afw::image;
namespace afwMath  = lsst::afw::math;
#endif

#include <stdio.h>
#include <bitset>
#include "clock.h"
#include <iostream>
using namespace std;

/*
 * The raw interface to Halide-compiled pipelines, declared in the generated
 * lincombo_aot.h header, passes memory arrays along with a simple description
 * of their layout, using a struct called buffer_t. A buffer_t is just an
 * untyped pointer to start of the data (`.host`), an optional pointer to a
 * corresponding GPU buffer (`.dev`), and a simple description of the layout
 * of up to a four dimensional grid in the pointed-to arrays:
 *
 *   elem_size specifies the size of a single element, e.g., sizeof(float)
 *
 *   stride[4] gives the stride for each dimension
 *
 *   extent[4] gives the extent (maximum coordinate) of each dimension
 *
 *   min[0] gives the minimum coordinate of each dimension (useful if the
 *          logical coordinates describe a crop into a larger virtual image)
 *
 * To access pixel (x, y) in a two-dimensional buffer_t, Halide
 * looks at memory address:
 *
 *    host + elem_size * ((x - min[0])*stride[0] + (y - min[1])*stride[1])
 *
 * This generalizes up to four dimensions. (A future release will generalize
 * it to arbitrary dimensions.)
 *
 * makeBuffer is a trivial helper function we use here to construct the
 * buffer descriptors for this example. There are other helper classes in
 * other code (Cf. `halide_image.h` in the Halide `tools` folder). For
 * integration with your own custom image objects like afwImage, you would
 * presumably create your own helpers.
 */
template <typename T>
buffer_t makeBuffer(int width, int height, T* data) {
    buffer_t buf = {0}; // initialize everything to 0

    // The host pointers point to the start of the image data:
    buf.host = reinterpret_cast<uint8_t*>(data);

    // The stride in a dimension represents the number of elements in
    // memory between adjacent entries in that dimension. We have a
    // grayscale image stored in scanline order, so stride[0] is 1,
    // because pixels that are adjacent in x are next to each other in
    // memory.
    buf.stride[0] = 1;

    // stride[1] is the width of the image, because pixels that are
    // adjacent in y are separated by a scanline's worth of pixels in
    // memory.
    buf.stride[1] = width;

    // buf.stride[2] = width*height..., but unnecessary for this example

    // The extent tells us how large the image is in each dimension.
    buf.extent[0] = width;
    buf.extent[1] = height;

    // We'll leave the mins as zero. This is what they typically
    // are. The host pointer points to the memory location of the min
    // coordinate (not the origin!).  See lesson 6 for more detail
    // about the mins.

    // The elem_size field tells us how many bytes each element
    // uses. This is 4 for floats and 2 for type uint16_t
    buf.elem_size = sizeof(T);

    return buf;
}

int main(int argc, char *argv[]) {

    //the precompiled Halide pipeline we are using expects 5 kernels
    //and 5 polynomials (each 3rd degree) with 10 coefficients
    const int num_kernels = 5;
    const int num_poly_coeff = 10;
    const int num_kernel_params = 3;

#ifdef USE_LSST_FITS_IO
    auto im = afwImage::MaskedImage<float>("./images/calexp-004207-g3-0123.fits");
    int width = im.getWidth(), height = im.getHeight();
#else
    int width = 2048, height = 1489;
    printf("[skipping load of FITS data]\n");
#endif
    printf("Loaded: %d x %d\n", width, height);

    float *image = new float[width*height];
    float *variance = new float[width*height];
    uint16_t *mask = new uint16_t[width*height];

#ifdef USE_LSST_FITS_IO
    //Read image, converting all three planes to uint8_t arrays
    //for passing to the aot compiled Halide
    // This is unnecessary, given a pointer to the raw arrays
    // underlying the afwImage; it should be easily possible to
    // directly wrap those in buffer_t structs for passing straight
    // into the Halide-generated pipeline.
    float curImage;
    float curVariance;
    uint16_t curMask;

    for (int y = 0; y < height; y++) {
        afwImage::MaskedImage<float, lsst::afw::image::MaskPixel, lsst::afw::image::VariancePixel>::x_iterator inPtr = im.x_at(0, y);
        for (int x = 0; x < width; x++){
            image[y*width + x] = (*inPtr).image();
            variance[y*width + x] = (*inPtr).variance();
            mask[y*width + x] = (*inPtr).mask();
            inPtr++;
        }
    }
#endif

    // Have a look in the header file above (it won't exist until you've run
    // linearCombination_aot_compile).

    // It starts with a definition of a buffer_t:
    //
    // typedef struct buffer_t {
    //     uint64_t dev;
    //     uint8_t* host;
    //     int32_t extent[4];
    //     int32_t stride[4];
    //     int32_t min[4];
    //     int32_t elem_size;
    //     bool host_dirty;
    //     bool dev_dirty;
    // } buffer_t;
    //
    // This is how Halide represents input and output images in
    // pre-compiled pipelines. There's a 'host' pointer that points to the
    // start of the image data, some fields that describe how to access
    // pixels, and some fields related to using the GPU that we'll ignore
    // for now (dev, host_dirty, dev_dirty).

    //Let's allocate the memory where we want to write our output:
    float *image_output = new float[width*height];
    float *variance_output = new float[width*height];
    uint16_t *mask_output = new uint16_t[width*height];

    //And the memory to store our parameters:
    //We need num_kernels*num_poly_coeff floats for the polynomial coefficents
    float *polynomial_coefficients = new float[num_kernels*num_poly_coeff];
    //We need num_kernels*num_kernel_params kernel parameters (2 standard deviations
    //and a rotation per kernel in this case)
    float *ker_params = new float[num_kernels*num_kernel_params];

    // In AOT-compiled mode, Halide doesn't manage this memory for
    // you. You should use whatever image data type makes sense for
    // your application. Halide just needs pointers to it.

    // Now we make a buffer_t to represent our input and output.
    buffer_t image_buf = makeBuffer(width, height, &image[0]);
    buffer_t variance_buf = makeBuffer(width, height, &variance[0]);
    buffer_t mask_buf = makeBuffer(width, height, &mask[0]);
    buffer_t poly_coef_buf = makeBuffer(num_poly_coeff, num_kernels, &polynomial_coefficients[0]);
    buffer_t ker_params_buf = makeBuffer(num_kernel_params, num_kernels, &ker_params[0]);
    buffer_t image_output_buf = makeBuffer(width, height, &image_output[0]);
    buffer_t variance_output_buf = makeBuffer(width, height, &variance_output[0]);
    buffer_t mask_output_buf = makeBuffer(width, height, &mask_output[0]);

    //Now we set the polynomial coeffecients
    float curCoef;

    //we are storing polynomial coefficients as poly_coef_buf(coef#, kernel#)
    for (int y = 0; y < num_kernels; y++) {
        int yy = y+1;
        for (int x = 0; x < num_poly_coeff; x++){
            int xx = x+1;
            curCoef = (float)y + ((float)x)/1000.0f;
            polynomial_coefficients[y*num_poly_coeff + x] = curCoef;
        }
    }

    //Now we set the kernel parameters
    float curParam;
    uint8_t *curParamUInt8Array;

    //we are storing kernel parameters as ker_params_buf(param#, kernel#)
    for (int y = 0; y < num_kernels; y++) {
        int yy = y + 1;
        for (int x = 0; x < num_kernel_params; x++){
            int xx = x + 1;
            curParam = (float)yy + ((float)xx)/1000.0f;
            ker_params[y*num_kernel_params + x] = curParam;
        }
    }

    // Now that we've setup all input and output buffers, it is now
    // time to call the main entrypoint function for the Halide
    // pipeline. Looking in the header file, it's signature is:
    //
    // int lincombo_aot(buffer_t *_image_buffer, buffer_t *_variance_buffer,
    //    buffer_t *_mask_buffer, buffer_t *_polynomialCoefficients_buffer,
    //    buffer_t *_kerParams_buffer, buffer_t *_combined_output_0_buffer,
    //    buffer_t *_combined_output_1_buffer, buffer_t *_combined_output_2_buffer);
    //
    // The return value is an error code. It's zero on success.

    int error = lincombo_aot(&image_buf, &variance_buf, &mask_buf, &poly_coef_buf,
        &ker_params_buf, &image_output_buf, &variance_output_buf, &mask_output_buf);

    if (error) {
        printf("Halide returned an error: %d\n", error);
        return -1;
    }

    // The following code is only for benchmarking.  It invokes the
    // Halide pipeline a number of times.
    double mean = 0;
    double min;
    double max;
    int numberOfRuns = 5;
    for (int i = 0; i < numberOfRuns; i++) {
        double t1 = current_time();
        error = lincombo_aot(&image_buf, &variance_buf, &mask_buf,
                             &poly_coef_buf, &ker_params_buf,
                             &image_output_buf,
                             &variance_output_buf,
                             &mask_output_buf);
        double t2 = current_time();
        double curTime = (t2-t1);
        mean += curTime;
        if (i == 0) {
            min = curTime;
            max = curTime;
        } else {
            if(curTime < min) min = curTime;
            if(curTime > max) max = curTime;
        }
    }
    mean = mean/numberOfRuns;

    std::cout << "Mean Time: " << mean
              << ", Min = " << min
              << ", Max = " << max
              << ", with " << numberOfRuns << " runs" << '\n';

#ifdef USE_LSST_FITS_IO
    bool writePlanesSeparately = false;
    if(!writePlanesSeparately){
        //write image out
        auto imOut = afwImage::MaskedImage<float, lsst::afw::image::MaskPixel,
            lsst::afw::image::VariancePixel>(im.getWidth(), im.getHeight());
        for (int y = 0; y < imOut.getHeight(); y++) {
            afwImage::MaskedImage<float, lsst::afw::image::MaskPixel,
                lsst::afw::image::VariancePixel>::x_iterator inPtr = imOut.x_at(0, y);
            for (int x = 0; x < imOut.getWidth(); x++){
                curImageUInt8Array = image_output + 4*(y*width + x);
                curVarianceUInt8Array = variance_output + 4*(y*width + x);
                curMaskUInt8Array = mask_output + 2*(y*width + x);

                curImage = *(reinterpret_cast<float*>(curImageUInt8Array));
                curVariance = *(reinterpret_cast<float*>(curVarianceUInt8Array));
                curMask = *(reinterpret_cast<uint16_t*>(curMaskUInt8Array));

                afwImage::pixel::SinglePixel<float, lsst::afw::image::MaskPixel,
                    lsst::afw::image::VariancePixel> curPixel(curImage, curMask, curVariance);

                (*inPtr) = curPixel;
                inPtr++;

            }
        }

        imOut.writeFits("./halideCleanLinearCombination5x5.fits");
    }
    else{
        //write three planes separately
        auto imOut = afwImage::MaskedImage<float, lsst::afw::image::MaskPixel, lsst::afw::image::VariancePixel>(im.getWidth(), im.getHeight());
        for (int y = 0; y < imOut.getHeight(); y++) {
            afwImage::MaskedImage<float, lsst::afw::image::MaskPixel, lsst::afw::image::VariancePixel>::x_iterator inPtr = imOut.x_at(0, y);

            for (int x = 0; x < imOut.getWidth(); x++){
                curImageUInt8Array = image_output + 4*(y*width + x);
                curImage = *(reinterpret_cast<float*>(curImageUInt8Array));
                afwImage::pixel::SinglePixel<float, lsst::afw::image::MaskPixel,
                lsst::afw::image::VariancePixel> curPixel(curImage, 0, 0);
                (*inPtr) = curPixel;
                inPtr++;

            }
        }

        auto varOut = afwImage::MaskedImage<float, lsst::afw::image::MaskPixel, lsst::afw::image::VariancePixel>(im.getWidth(), im.getHeight());
        for (int y = 0; y < imOut.getHeight(); y++) {
            afwImage::MaskedImage<float, lsst::afw::image::MaskPixel, lsst::afw::image::VariancePixel>::x_iterator inPtr = varOut.x_at(0, y);

            for (int x = 0; x < imOut.getWidth(); x++){
                curVarianceUInt8Array = variance_output + 4*(y*width + x);
                curVariance = *(reinterpret_cast<float*>(curVarianceUInt8Array));

                afwImage::pixel::SinglePixel<float, lsst::afw::image::MaskPixel,
                lsst::afw::image::VariancePixel> curPixel(curVariance, 0, 0);
                (*inPtr) = curPixel;
                inPtr++;

            }
        }

        auto maskOutPlane = afwImage::MaskedImage<float, lsst::afw::image::MaskPixel, lsst::afw::image::VariancePixel>(im.getWidth(), im.getHeight());
        for (int y = 0; y < imOut.getHeight(); y++) {
            afwImage::MaskedImage<float, lsst::afw::image::MaskPixel, lsst::afw::image::VariancePixel>::x_iterator inPtr = maskOutPlane.x_at(0, y);

            for (int x = 0; x < imOut.getWidth(); x++){
                curMaskUInt8Array = mask_output + 2*(y*width + x);
                curMask = *(reinterpret_cast<uint16_t*>(curMaskUInt8Array));

                afwImage::pixel::SinglePixel<float, lsst::afw::image::MaskPixel,
                lsst::afw::image::VariancePixel> curPixel(curMask, 0, 0);
                (*inPtr) = curPixel;
                inPtr++;

            }
        }

        imOut.writeFits("./halideLinComboImage5x5.fits");
        varOut.writeFits("./halideLinComboVar5x5.fits");
        maskOutPlane.writeFits("./halideLinComboMask5x5.fits");
    }
#endif

    delete[] image;
    delete[] variance;
    delete[] mask;
    delete[] polynomial_coefficients;
    delete[] ker_params;
    delete[] image_output;
    delete[] variance_output;
    delete[] mask_output;
    return 0;
}


